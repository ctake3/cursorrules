# ユーザー入力:
[TASK]: <タスクの説明を入力>  
[PROJECT OVERVIEW]: <プロジェクト概要を入力、または詳細を含むファイルへのリンクを記入>   
[MAIN BRANCH]: master

---

# グローバル目標
1. 以下の「ユーザー入力」を確認すること
2. このプロンプト全体を注意深く読むこと
3. 「実行手順」に従うこと
4. 各確認ポイントで人間による確認を待つこと
5. タスクファイルを中心的な情報源として維持すること

<<< 停止 >>>
> 上記のグローバル目標を完全に理解した場合、「I understand the main objectives」と返信してください。また次の内容を含めて返信してください:
> - グローバル目標の要約
> - 実行手順をステップごとに繰り返す

---

# 実行手順:

## 1. Gitブランチの作成
1. [MAIN BRANCH]から新しいタスクブランチを作成します:  
   
git checkout -b task/[TASK_IDENTIFIER]_[TASK_DATE_AND_NUMBER]

2. ブランチ名を[TASK FILE]の「Task Branch」に記入します。
3. ブランチがアクティブであることを確認します:  
   
git branch --show-current


## 2. タスク分析
- [TASK]、関連コード、機能をステップごとに確認します。  

<<< 停止: 続行する前に、分析が完了したことをユーザーに確認してください。完了していない場合は繰り返します >>>

## 3. タスクファイルの作成
1. [TASK FILE]を作成し、名前を[TASK_FILE_NAME]_[TASK_IDENTIFIER].mdとし、プロジェクトルートの.tasksディレクトリに配置します。
2. 「Placeholder Definitions」のすべての内容を[TASK FILE]に追加します。
   - 他の開発者がこれらのプレースホルダーの意味を理解できるようにするためです。
3. その後、次の内容を使用して「タスクファイルテンプレート」の全体を埋めます:
   - 実行手順2の結果
   - ユーザーから提供された入力

<<< 停止: 続行する前に、[TASK FILE]の名前と内容についてユーザーの確認を待ちます >>>

## **4. タスクの反復**
1. 変更前にコードコンテキストを完全に分析します。  
2. [TASK FILE]の「Task Progress」に記録されている更新を分析し、過去のミスや不成功な変更を繰り返さないようにします。
3. 必要に応じてコードベースに変更を加えます。  
4. [TASK FILE]の「Task Progress」に進捗状況を更新します。  
5. 各変更について:
   - 更新内容をユーザーに確認します。
   - ユーザー確認後、変更をログにSUCCESSFULまたはUNSUCCESSFULとして記録します。
   必要に応じて:
    - コードをコミットする
        - 必要であると判断された場合のみ
        
git commit -m "[SHORT_MESSAGE]"


<<< 停止: 続行する前に、変更が成功したかどうかユーザーに確認し、失敗した場合はこの実行手順を再度繰り返します >>>

## **5. タスク完了**
1. ユーザーの確認後:
   - すべての変更をステージングします:
     
git add -A

   - 簡潔なメッセージでコミットします:
     
git commit -m "[SHORT_MESSAGE]"


<<< 停止: 続行する前に、[TASK BRANCH]を[MAIN BRANCH]にマージするかどうかユーザーに確認します。マージしない場合、実行手順8に進みます >>>

## **6. タスクブランチのマージ**
1. [MAIN BRANCH]へのマージをユーザーに確認します。
2. 承認された場合:
   - [MAIN BRANCH]をチェックアウトします:  
     
git checkout [MAIN BRANCH]

   - マージします:  
     
git merge task/[TASK_IDENTIFIER]_[TASK_DATE_AND_NUMBER]

3. 次のコマンドを実行してマージが成功したことを確認します:
   
git log [TASK BRANCH]..[MAIN BRANCH]


## **7. タスクブランチの削除**
1. [TASK BRANCH]を削除するかどうかユーザーに確認します。削除しない場合、実行手順8に進みます。
2. [TASK BRANCH]を削除します:  
   
git branch -d task/[TASK_IDENTIFIER]_[TASK_DATE_AND_NUMBER]


<<< 停止: 続行する前に、git branch --listを確認して[TASK BRANCH]が正常に削除されたことを確認します >>>

## **8. 最終確認**
1. 実行したすべての内容を確認し、「Final Review」を[TASK FILE]に記入します。

<<< 停止: 完了する前に、ユーザーに最終レビューを提供します >>>

---

# タスクファイルテンプレート:
markdown
# コンテキスト
タスクファイル名: [TASK_FILE_NAME]
作成日: [DATETIME]
作成者: [USER_NAME]

# タスク説明
[ユーザーによって提供された[TASK]に基づく詳細な説明]

# プロジェクト概要
[ユーザーによって提供された[PROJECT OVERVIEW]に基づく詳細な概要]

# 元のタスクテンプレート
[未編集の「タスクファイルテンプレート」を完全にコピーしてこのセクションに含めます]
- このセクションには、すべての詳細を含めて、未編集の「タスクファイルテンプレート」をコピーして貼り付けます
- マークダウンコードブロックで囲みます
- このセクションの最後に「DO NOT REMOVE」と追加します（必要に応じて参照のため）。

# 元の実行手順
[未編集の「実行手順」セクション全体をこのセクションにコピーして含めます]
- 各実行手順に含まれるすべての詳細を含めて、未編集の「実行手順」セクションをコピーして貼り付けます
- マークダウンコードブロックで囲みます
- このセクションの最後に「DO NOT REMOVE」と追加します（必要に応じて参照のため）。

# タスク分析
- [TASK]の目的。
- 特定された問題を含む:
  - 発生した問題。
  - 解決が必要な理由。
  - 実装の詳細と目標。
- その他の有用な参考詳細。

# メインブランチ
[MAIN BRANCH]

# タスクブランチ
[TASK BRANCH]

# 実行すべきステップ
[タスクの実行可能なステップのリスト]
- タスクがない場合は「—」

# 現在の実行ステップ: [現在の実行ステップの番号]

# タスク進捗
- 更新には次を含める必要があります:
  - 必須:
    - [DATETIME]
    - ユーザー確認後、SUCCESSFUL/UNSUCCESSFUL
  - 任意:
    - 発見事項、解決策、ブロッカー、結果。
    - すべての更新を時系列に記録します。

# 最終レビュー
[タスク完了後にのみ記入します。]


---

# プレースホルダーの定義:
[プロンプト全体で使用されるプレースホルダーの説明]
- [TASK]: 対処している具体的なタスクまたは問題（例:「fix-cache-manager」）
- [TASK_IDENTIFIER]: タスクのユニークで分かりやすい識別子（例:「fix-cache-manager」）
- [TASK_FILE_NAME]: タスクファイルの名前
- [TASK_DATE_AND_NUMBER]: タスクファイルのタイムスタンプおよび連番識別子（例:「2025-01-14_1」）
- [MAIN BRANCH]: メイン開発が行われるブランチ（デフォルト:「master」）
- [TASK FILE]: タスクの進捗を文書化し追跡するために作成されたMarkdownファイル
- [TASK BRANCH]: タスクの変更が実装されるGitブランチ
- [DATETIME]: 現在の日付と時刻
- [DATE]: 現在の日付
- [TIME]: 現在の時刻
- [USER_NAME]: 現在のユーザー名
- 一部のプレースホルダーを埋めるためのコマンド:
   - [TASK_FILE_NAME]: echo $(date +%Y-%m-%d)_$(($(find .tasks -maxdepth 1 -name "$(date +%Y-%m-%d)_*" | wc -l) + 1))
   - [DATETIME]: echo $(date +'%Y-%m-%d_%H:%M:%S')
   - [DATE]: echo $(date +'%Y-%m-%d')
   - [TIME]: echo $(date +'%H:%M:%S')
   - [USER_NAME]: echo $(whoami)